<div id="particle-canvas-container"></div>

<script>
    // =======================================================
    // == GLOBAL PARAMETERS TO TWEAK THE ANIMATION ==
    // =======================================================
    const PARTICLE_COUNT = 300;
    const MAX_SPEED = 1.5;
    const TURBULENCE = 2 * Math.PI * 2;
    // How chaotic the flow is
    const FIELD_MAGNITUDE = 0.1;
    // How strongly particles follow the flow

    // --- COLOR SETTINGS ---
    const PARTICLE_ALPHA = 20;
    // Opacity of particle trails (0-255)
    const FADE_ALPHA = 10;
    // How quickly trails fade (0-255)
    const RGB_LOW = 30;
    // Low end for random color channels (0-255)
    const RGB_HIGH = 255;
    // High end for random color channels (0-255)
    const BACKGROUND_RGB = [239, 241, 245];
    // Your --base00 color

    // =======================================================

    class Particle {
        constructor(p) {
            this.p = p;
            this.pos = p.createVector(p.random(p.width), p.random(p.height));
            this.prevPos = this.pos.copy();
            this.vel = p.createVector(0, 0);
            this.acc = p.createVector(0, 0);
            this.maxSpeed = MAX_SPEED;
            // Use the global color parameters
            this.color = [
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
                PARTICLE_ALPHA,
            ];
        }

        update() {
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);
        }

        updatePrev() {
            this.prevPos.x = this.pos.x;
            this.prevPos.y = this.pos.y;
        }

        applyForce(force) {
            this.acc.add(force);
        }

        show() {
            this.p.stroke(this.color);
            this.p.strokeWeight(1);
            this.p.line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);
            this.updatePrev();
        }

        edges() {
            if (this.pos.x > this.p.width) {
                this.pos.x = 0;
                this.updatePrev();
            }
            if (this.pos.x < 0) {
                this.pos.x = this.p.width;
                this.updatePrev();
            }
            if (this.pos.y > this.p.height) {
                this.pos.y = 0;
                this.updatePrev();
            }
            if (this.pos.y < 0) {
                this.pos.y = this.p.height;
                this.updatePrev();
            }
        }

        follow(flowfield) {
            const x = Math.floor(this.pos.x / 20);
            const y = Math.floor(this.pos.y / 20);
            const index = x + y * Math.floor(this.p.width / 20);
            const force = flowfield[index];
            if (force) {
                this.applyForce(force);
            }
        }
    }

    const sketch = (p) => {
        let particles = [];
        let flowfield;

        p.setup = () => {
            const container = document.getElementById(
                "particle-canvas-container",
            );
            const canvas = p.createCanvas(
                document.body.scrollWidth,
                document.body.scrollHeight,
            );
            canvas.parent(container);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles[i] = new Particle(p);
            }
            p.background(BACKGROUND_RGB);
        };
        p.draw = () => {
            p.background(
                BACKGROUND_RGB[0],
                BACKGROUND_RGB[1],
                BACKGROUND_RGB[2],
                FADE_ALPHA,
            );
            const cols = Math.floor(p.width / 20);
            const rows = Math.floor(p.height / 20);
            flowfield = new Array(cols * rows);
            let yoff = 0;
            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle =
                        p.noise(xoff, yoff, p.frameCount * 0.0005) * TURBULENCE;
                    const v = p5.Vector.fromAngle(angle);
                    v.setMag(FIELD_MAGNITUDE);
                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].follow(flowfield);
                particles[i].update();
                particles[i].show();
                particles[i].edges();
            }
        };

        const resizeCanvasToBody = () => {
            p.resizeCanvas(
                document.body.scrollWidth,
                document.body.scrollHeight,
            );
        };

        // Use a ResizeObserver to handle content changes
        const observer = new ResizeObserver(resizeCanvasToBody);
        observer.observe(document.body);
    };

    document.addEventListener("DOMContentLoaded", () => {
        if (window.p5) {
            new window.p5(sketch);
        }
    });
</script>

<style>
    #particle-canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }
</style>
