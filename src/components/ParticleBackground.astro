<div id="particle-canvas-container"></div>
<script>
    // =======================================================
    // == GLOBAL PARAMETERS TO TWEAK THE ANIMATION ==
    // =======================================================
    const PARTICLE_COUNT = 300;
    const MAX_SPEED = 1.5;
    const TURBULENCE = 2 * Math.PI * 2;
    const FIELD_MAGNITUDE = 0.1;
    // How strongly particles follow the flow

    // --- COLOR SETTINGS ---
    const PARTICLE_ALPHA = 40;
    // Opacity of particle trails (0-255)
    const RGB_LOW = 30;
    const RGB_HIGH = 255;
    const BACKGROUND_RGB = [239, 241, 245];
    // Your --base00 color
	const TRAIL_LENGTH = 300; // Number of previous positions to remember
// Get CSS variables from :root
const rootStyles = getComputedStyle(document.documentElement);

// Collect the base08â€“base0F colors into an array
const palette = [
  rootStyles.getPropertyValue("--base08").trim(),
  rootStyles.getPropertyValue("--base09").trim(),
  rootStyles.getPropertyValue("--base0A").trim(),
  rootStyles.getPropertyValue("--base0B").trim(),
  rootStyles.getPropertyValue("--base0C").trim(),
  rootStyles.getPropertyValue("--base0D").trim(),
  rootStyles.getPropertyValue("--base0E").trim(),
  rootStyles.getPropertyValue("--base0F").trim(),
];


// Convert to rgba with alpha if you want the same style as before
function hexToRgba(hex, alpha = 1.0) {
  const bigint = parseInt(hex.slice(1), 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return [r, g, b, alpha];
}

    // =======================================================

    class Particle {
        // The constructor now accepts the contentMap to check for valid spawn points
        constructor(p, contentMap) {
            this.p = p;
            this.pos = p.createVector(p.random(p.width), p.random(p.height));
            this.vel = p.createVector(0, 0);
            this.acc = p.createVector(0, 0);
            this.maxSpeed = MAX_SPEED;
// Pick one at random
const randomHex = palette[Math.floor(Math.random() * palette.length)];
this.color = hexToRgba(randomHex, PARTICLE_ALPHA);
			this.trail = [];
        }

        update() {
			this.trail.push(this.pos.copy());
			if (this.trail.length > TRAIL_LENGTH) {
				this.trail.shift();
			}
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);
        }


        applyForce(force) {
            this.acc.add(force);
        }

        show() {
            this.p.stroke(this.color);
            this.p.strokeWeight(1);
			for (let i = 0; i < this.trail.length - 1; i++) {
				const x1 = this.trail[i].x;
				const y1 = this.trail[i].y;
				const x2 = this.trail[i + 1].x;
				const y2 = this.trail[i + 1].y;
				const alpha = this.p.map(
                        i,
                        0,
                        this.trail.length - 1,
                        5,
                        PARTICLE_ALPHA,
                    );

                    this.p.stroke(
                        this.color[0],
                        this.color[1],
                        this.color[2],
                        alpha,
                    );

                    this.p.line(x1, y1, x2, y2); 
			}
        }

        edges() {
            if (this.pos.x > this.p.width) {
                this.pos.x = 0;
				this.trail = [];
            }
            if (this.pos.x < 0) {
                this.pos.x = this.p.width;
				this.trail = [];
            }
            if (this.pos.y > this.p.height) {
                this.pos.y = 0;
				this.trail = [];
            }
            if (this.pos.y < 0) {
                this.pos.y = this.p.height;
				this.trail = [];
            }
        }

        follow(flowfield) {
            const x = Math.floor(this.pos.x / 20);
            const y = Math.floor(this.pos.y / 20);
            const index = x + y * Math.floor(this.p.width / 20);
            const force = flowfield[index];
            if (force) this.applyForce(force);
        }

        avoid(contentMap) {
            if (
                this.pos.x < 0 ||
                this.pos.x >= contentMap.width ||
                this.pos.y < 0 ||
                this.pos.y >= contentMap.height
            )
                return;
            const checkPixel = contentMap.get(this.pos.x, this.pos.y);
            if (checkPixel[0] < 255) {
                const avoidanceForce = p5.Vector.random2D().mult(
                    this.maxSpeed * REPULSION_FACTOR,
                );

                this.applyForce(avoidanceForce);
            }
        }
    }

    const sketch = (p) => {
        let particles = [];
        let flowfield;
        let contentMap;

        const updateContentMap = () => {
            if (!contentMap) return;
            contentMap.background(255);
            contentMap.noStroke();
            contentMap.fill(0);
            const contentElements = document.querySelectorAll(
                "nav, main > section, footer",
            );
            contentElements.forEach((el) => {
                const rect = el.getBoundingClientRect();
                // We add scrollY to get the element's position relative to the document, not the viewport
                contentMap.rect(
                    rect.left,
                    rect.top + window.scrollY,
                    rect.width,
                    rect.height,
                );
            });
        };

        p.setup = () => {
// Select the container div
    const canvasContainer = p.select('#particle-canvas-container');

    // Get its width and height, which are set by the CSS
    const w = canvasContainer.width;
    const h = canvasContainer.height;

    // Create the canvas with those dimensions
    const canvas = p.createCanvas(w, h);

    // Tell the canvas to live inside that container
    canvas.parent('particle-canvas-container');

            contentMap = p.createGraphics(p.width, p.height);
            updateContentMap(); // Create the map *before* creating particles

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle(p, contentMap)); // Pass the map to the constructor
            }
            p.background(BACKGROUND_RGB);
        };

        // This is the cleanest way to handle resizing
        p.windowResized = () => {
            p.resizeCanvas(
                document.body.scrollWidth,
                document.body.scrollHeight,
            );
            contentMap = p.createGraphics(p.width, p.height);
            updateContentMap();
        };

        p.draw = () => {
p.background(
                BACKGROUND_RGB[0],
                BACKGROUND_RGB[1],
                BACKGROUND_RGB[2],
            );
            const cols = Math.floor(p.width / 20);
            const rows = Math.floor(p.height / 20);
            flowfield = new Array(cols * rows);
            let yoff = 0;
            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle =
                        p.noise(xoff, yoff, p.frameCount * 0.0005) * TURBULENCE;
                    const v =
                        p5.Vector.fromAngle(angle).setMag(FIELD_MAGNITUDE);
                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }
            particles.forEach((particle) => {
                particle.avoid(contentMap);
                particle.follow(flowfield);
                particle.update();
                particle.show();
                particle.edges();
            });
        };
    };

    window.onload = () => {
        const container = document.getElementById("particle-canvas-container");
        if (window.p5 && container) {
            new window.p5(sketch);
        }
    };
</script>
<style>
    #particle-canvas-container {
        /* Use position: fixed to lock it to the viewport */
        position: absolute;
        top: 0;
        left: 0;
        margin-bottom: 0;
        padding-bottom: 0;
        width: 100%;
        height: calc(100% - 80px);
        z-index: -1;
    }
</style>
