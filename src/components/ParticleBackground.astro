<div id="particle-canvas-container"></div>

<script>
    // =======================================================
    // == GLOBAL PARAMETERS TO TWEAK THE ANIMATION ==
    // =======================================================
    const PARTICLE_COUNT = 300;
    const MAX_SPEED = 1.5;
    const TURBULENCE = 2 * Math.PI * 2;
    // How chaotic the flow is
    const FIELD_MAGNITUDE = 0.1;
    // How strongly particles follow the flow

    // --- COLOR SETTINGS ---
    const PARTICLE_ALPHA = 40;
    // Opacity of particle trails (0-255)
    const RGB_LOW = 30;
    // Low end for random color channels (0-255)
    const RGB_HIGH = 255;
    // High end for random color channels (0-255)
    const BACKGROUND_RGB = [239, 241, 245];
    // Your --base00 color

    // Trail length control
    const TRAIL_LENGTH = 15; // Number of previous positions to remember

    // =======================================================

    class Particle {
        constructor(p) {
            this.p = p;
            // Initialize position in a virtual space larger than viewport
            const virtualHeight = Math.max(
                document.body.scrollHeight,
                window.innerHeight,
            );
            const virtualWidth = Math.max(
                document.body.scrollWidth,
                window.innerWidth,
            );

            this.pos = p.createVector(
                p.random(virtualWidth),
                p.random(virtualHeight),
            );
            this.vel = p.createVector(0, 0);
            this.acc = p.createVector(0, 0);
            this.maxSpeed = MAX_SPEED;
            // Store multiple previous positions for smooth fading trails
            this.trail = [];
            // Use the global color parameters
            this.color = [
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
            ];
        }

        update() {
            // Store current position in trail
            this.trail.push(this.pos.copy());

            // Keep trail length manageable
            if (this.trail.length > TRAIL_LENGTH) {
                this.trail.shift();
            }

            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);
        }

        applyForce(force) {
            this.acc.add(force);
        }

        show() {
            const scrollX =
                window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY =
                window.pageYOffset || document.documentElement.scrollTop;

            // Draw trail with fading alpha, adjusted for scroll position
            this.p.strokeWeight(1);
            for (let i = 0; i < this.trail.length - 1; i++) {
                // Calculate screen position relative to scroll
                const x1 = this.trail[i].x - scrollX;
                const y1 = this.trail[i].y - scrollY;
                const x2 = this.trail[i + 1].x - scrollX;
                const y2 = this.trail[i + 1].y - scrollY;

                // Only draw if the line segment is visible on screen
                if (this.isLineVisible(x1, y1, x2, y2)) {
                    // Calculate alpha based on position in trail (newer = more opaque)
                    const alpha = this.p.map(
                        i,
                        0,
                        this.trail.length - 1,
                        5,
                        PARTICLE_ALPHA,
                    );
                    this.p.stroke(
                        this.color[0],
                        this.color[1],
                        this.color[2],
                        alpha,
                    );

                    this.p.line(x1, y1, x2, y2);
                }
            }
        }

        isLineVisible(x1, y1, x2, y2) {
            // Simple bounds check - is any part of the line visible on screen?
            const margin = 50; // Small margin for smoother transitions
            return (
                !(x1 < -margin && x2 < -margin) &&
                !(x1 > this.p.width + margin && x2 > this.p.width + margin) &&
                !(y1 < -margin && y2 < -margin) &&
                !(y1 > this.p.height + margin && y2 > this.p.height + margin)
            );
        }

        edges() {
            const virtualHeight = Math.max(
                document.body.scrollHeight,
                window.innerHeight,
            );
            const virtualWidth = Math.max(
                document.body.scrollWidth,
                window.innerWidth,
            );

            if (this.pos.x > virtualWidth) {
                this.pos.x = 0;
                this.trail = []; // Clear trail when wrapping
            }
            if (this.pos.x < 0) {
                this.pos.x = virtualWidth;
                this.trail = [];
            }
            if (this.pos.y > virtualHeight) {
                this.pos.y = 0;
                this.trail = [];
            }
            if (this.pos.y < 0) {
                this.pos.y = virtualHeight;
                this.trail = [];
            }
        }

        follow(flowfield, scrollX, scrollY) {
            // Use scroll-adjusted position for flowfield calculation
            const adjustedX = this.pos.x - scrollX;
            const adjustedY = this.pos.y - scrollY;

            const x = Math.floor(adjustedX / 20);
            const y = Math.floor(adjustedY / 20);
            const cols = Math.floor(this.p.width / 20);
            const index = x + y * cols;

            if (x >= 0 && x < cols && y >= 0 && index < flowfield.length) {
                const force = flowfield[index];
                if (force) {
                    this.applyForce(force);
                }
            }
        }
    }

    const sketch = (p) => {
        let particles = [];
        let flowfield;

        p.setup = () => {
            const container = document.getElementById(
                "particle-canvas-container",
            );
            // Use viewport dimensions but make particles aware of scroll
            const canvas = p.createCanvas(
                window.innerWidth,
                window.innerHeight,
            );
            canvas.parent(container);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles[i] = new Particle(p);
            }

            // Use solid background instead of semi-transparent overlay
            p.background(BACKGROUND_RGB);
        };

        p.draw = () => {
            // Clear the background completely each frame for clean trails
            p.background(
                BACKGROUND_RGB[0],
                BACKGROUND_RGB[1],
                BACKGROUND_RGB[2],
            );

            // Get current scroll position
            const scrollX =
                window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY =
                window.pageYOffset || document.documentElement.scrollTop;

            const cols = Math.floor(p.width / 20);
            const rows = Math.floor(p.height / 20);
            flowfield = new Array(cols * rows);
            let yoff = scrollY * 0.0001; // Factor scroll into noise

            for (let y = 0; y < rows; y++) {
                let xoff = scrollX * 0.0001;
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle =
                        p.noise(xoff, yoff, p.frameCount * 0.0005) * TURBULENCE;
                    const v = p5.Vector.fromAngle(angle);
                    v.setMag(FIELD_MAGNITUDE);
                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }

            for (let i = 0; i < particles.length; i++) {
                particles[i].follow(flowfield, scrollX, scrollY);
                particles[i].update();
                particles[i].show();
                particles[i].edges();
            }
        };

        p.windowResized = () => {
            p.resizeCanvas(window.innerWidth, window.innerHeight);
        };
    };

    document.addEventListener("DOMContentLoaded", () => {
        if (window.p5) {
            new window.p5(sketch);
        }
    });
</script>

<style>
    #particle-canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
        pointer-events: none;
    }
</style>
