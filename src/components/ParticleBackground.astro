<div id="particle-canvas-container"></div>
<script>
    // =======================================================
    // == GLOBAL PARAMETERS TO TWEAK THE ANIMATION ==
    // =======================================================
    const PARTICLE_COUNT = 300;
    const MAX_SPEED = 1.5;
    const TURBULENCE = 2 * Math.PI * 2;
    const FIELD_MAGNITUDE = 0.1;
    const FADE_ALPHA = 30;
    const PARTICLE_ALPHA = 20;
    const RGB_LOW = 30;
    const RGB_HIGH = 255;
    const BACKGROUND_RGB = [239, 241, 245];
    const REPULSION_FACTOR = 1000;

    // =======================================================

    class Particle {
        // The constructor now accepts the contentMap to check for valid spawn points
        constructor(p, contentMap) {
            this.p = p;

            // Find a valid starting position
            let x, y;
            do {
                x = p.random(p.width);
                y = p.random(p.height);
            } while (contentMap.get(x, y)[0] < 255); // Keep trying until we find a white pixel

            this.pos = p.createVector(x, y);
            this.prevPos = this.pos.copy();
            this.vel = p.createVector(0, 0);
            this.acc = p.createVector(0, 0);
            this.maxSpeed = MAX_SPEED;
            this.color = [
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
                p.random(RGB_LOW, RGB_HIGH),
                PARTICLE_ALPHA,
            ];
        }

        update() {
            this.vel.add(this.acc);
            this.vel.limit(this.maxSpeed);
            this.pos.add(this.vel);
            this.acc.mult(0);
        }

        updatePrev() {
            this.prevPos.x = this.pos.x;
            this.prevPos.y = this.pos.y;
        }

        applyForce(force) {
            this.acc.add(force);
        }

        show() {
            this.p.stroke(this.color);
            this.p.strokeWeight(1);
            this.p.line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);
            this.updatePrev();
        }

        edges() {
            if (this.pos.x > this.p.width) (this.pos.x = 0), this.updatePrev();
            if (this.pos.x < 0) (this.pos.x = this.p.width), this.updatePrev();
            if (this.pos.y > this.p.height) (this.pos.y = 0), this.updatePrev();
            if (this.pos.y < 0) (this.pos.y = this.p.height), this.updatePrev();
        }

        follow(flowfield) {
            const x = Math.floor(this.pos.x / 20);
            const y = Math.floor(this.pos.y / 20);
            const index = x + y * Math.floor(this.p.width / 20);
            const force = flowfield[index];
            if (force) this.applyForce(force);
        }

        avoid(contentMap) {
            if (
                this.pos.x < 0 ||
                this.pos.x >= contentMap.width ||
                this.pos.y < 0 ||
                this.pos.y >= contentMap.height
            )
                return;
            const checkPixel = contentMap.get(this.pos.x, this.pos.y);
            if (checkPixel[0] < 255) {
                const avoidanceForce = p5.Vector.random2D().mult(
                    this.maxSpeed * REPULSION_FACTOR,
                );

                this.applyForce(avoidanceForce);
            }
        }
    }

    const sketch = (p) => {
        let particles = [];
        let flowfield;
        let contentMap;

        const updateContentMap = () => {
            if (!contentMap) return;
            contentMap.background(255);
            contentMap.noStroke();
            contentMap.fill(0);
            const contentElements = document.querySelectorAll(
                "nav, main > section, footer",
            );
            contentElements.forEach((el) => {
                const rect = el.getBoundingClientRect();
                // We add scrollY to get the element's position relative to the document, not the viewport
                contentMap.rect(
                    rect.left,
                    rect.top + window.scrollY,
                    rect.width,
                    rect.height,
                );
            });
        };

        p.setup = () => {
            const container = document.getElementById(
                "particle-canvas-container",
            );
            const canvas = p.createCanvas(
                document.body.scrollWidth,
                document.body.scrollHeight,
            );
            canvas.parent(container);

            contentMap = p.createGraphics(p.width, p.height);
            updateContentMap(); // Create the map *before* creating particles

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle(p, contentMap)); // Pass the map to the constructor
            }
            p.background(BACKGROUND_RGB);
        };

        // This is the cleanest way to handle resizing
        p.windowResized = () => {
            p.resizeCanvas(
                document.body.scrollWidth,
                document.body.scrollHeight,
            );
            contentMap = p.createGraphics(p.width, p.height);
            updateContentMap();
        };

        p.draw = () => {
            p.background(
                BACKGROUND_RGB[0],
                BACKGROUND_RGB[1],
                BACKGROUND_RGB[2],
                FADE_ALPHA,
            );
            const cols = Math.floor(p.width / 20);
            const rows = Math.floor(p.height / 20);
            flowfield = new Array(cols * rows);
            let yoff = 0;
            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    const index = x + y * cols;
                    const angle =
                        p.noise(xoff, yoff, p.frameCount * 0.0005) * TURBULENCE;
                    const v =
                        p5.Vector.fromAngle(angle).setMag(FIELD_MAGNITUDE);
                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }
            particles.forEach((particle) => {
                particle.avoid(contentMap);
                particle.follow(flowfield);
                particle.update();
                particle.show();
                particle.edges();
            });
        };
    };

    window.onload = () => {
        const container = document.getElementById("particle-canvas-container");
        if (window.p5 && container) {
            new window.p5(sketch);
        }
    };
</script>
<style>
    #particle-canvas-container {
        /* Use position: fixed to lock it to the viewport */
        position: absolute;
        top: 0;
        left: 0;
        margin-bottom: 0;
        padding-bottom: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
    }
</style>
